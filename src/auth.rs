use actix_web::{web, HttpResponse, Responder};
use bcrypt::{hash, verify, DEFAULT_COST};
use chrono::{Utc, Duration};
use jsonwebtoken::{encode, decode, EncodingKey, DecodingKey, Header, Validation};
use mongodb::bson::{doc, oid::ObjectId, Document};
use serde::{Deserialize, Serialize};
use crate::app_state::AppState;

/// Signup info – team_id is optional so new users can sign up without an existing team.
#[derive(Serialize, Deserialize, Debug)]
pub struct SignupInfo {
    pub username: String,
    pub password: String,
    pub email: String,
    pub team_id: Option<String>,
}

/// Login info
#[derive(Serialize, Deserialize, Debug)]
pub struct LoginInfo {
    pub username: String,
    pub password: String,
}

/// JWT Claims – the sub field now holds the unique user identifier (the MongoDB _id as hex)
#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    pub sub: String,      // Unique user ID (from MongoDB _id)
    pub team_id: String,  // Will be empty if the user is not yet assigned to a team
    pub exp: usize,
}

/// Create a JWT token from the user_id and team_id
pub fn create_jwt(user_id: &str, team_id: &str, secret: &str) -> String {
    let expiration = Utc::now() + Duration::hours(24);
    let claims = Claims {
        sub: user_id.to_string(),
        team_id: team_id.to_string(),
        exp: expiration.timestamp() as usize,
    };
    encode(&Header::default(), &claims, &EncodingKey::from_secret(secret.as_ref())).unwrap()
}

/// Sign-up endpoint
pub async fn signup(data: web::Data<AppState>, info: web::Json<SignupInfo>) -> impl Responder {
    // Hash the password
    let hashed_password = match hash(&info.password, DEFAULT_COST) {
        Ok(h) => h,
        Err(_) => return HttpResponse::InternalServerError().body("Error hashing password"),
    };

    // Use a default team value if none is provided
    let team = info.team_id.clone().unwrap_or_default();

    // Create the new user document (note: _id is generated by MongoDB)
    let user: Document = doc! {
        "username": &info.username,
        "email": &info.email,
        "password": hashed_password,
        "team_id": team,
    };

    let users_collection = data.mongodb.db.collection::<Document>("users");
    match users_collection.insert_one(user).await {
        Ok(_) => HttpResponse::Ok().body("User created"),
        Err(e) => HttpResponse::InternalServerError().body(format!("Error creating user: {}", e)),
    }
}

/// Login endpoint
pub async fn login(data: web::Data<AppState>, info: web::Json<LoginInfo>) -> impl Responder {
    let users_collection = data.mongodb.db.collection::<Document>("users");

    match users_collection.find_one(doc! { "username": &info.username }).await {
        Ok(Some(user)) => {
            let password_hash = match user.get_str("password") {
                Ok(p) => p,
                Err(_) => return HttpResponse::InternalServerError().body("Password missing"),
            };

            if verify(&info.password, password_hash).unwrap_or(false) {
                // Use the MongoDB _id as the unique user id (converted to a hex string)
                let user_id = match user.get_object_id("_id") {
                    Ok(oid) => oid.to_hex(),
                    Err(_) => return HttpResponse::InternalServerError().body("User ID missing"),
                };
                // Retrieve team_id; if missing, default to empty string
                let team_id = user.get_str("team_id").unwrap_or("").to_string();
                let token = create_jwt(&user_id, &team_id, &data.config.jwt_secret);
                HttpResponse::Ok().json(serde_json::json!({ "token": token }))
            } else {
                HttpResponse::Unauthorized().body("Invalid credentials")
            }
        }
        _ => HttpResponse::Unauthorized().body("User not found"),
    }
}
